# Метадата

## Основа

Каждый предмет может иметь в себе метадату ограничивающуюся лишь размером `Integer`(2147483647). Для того, чтобы добавить метадату предмету нужно добавить в конструктор `setHasSubtypes` и выставить значение на `true`. Пример: `setHasSubtypes(true)`. Данная функция будет говорить Minecraft о том, что наш предмет имеет подтипы.

Добавим в класс с нашим предметом метод `getSubItems`:
```java
@Override
public void getSubItems(CreativeTabs tab, NonNullList<ItemStack> items)
{

}
```

Для создания предметов с метадатой рекомендуется использовать перечисляемые типы(Enum). Пример такого класса:
```java
public enum AppleTypes
{
    //типы, начинаются от 0.
    ANTONOVKA, PAPIROVKA, WHITEFILLING;

    //получение типа по метадате
    public static AppleTypes getByMeta(int meta)
    {
        for (AppleTypes type : values())
        {
            if (type.ordinal() == meta)
                return type;
        }
        return null;
    }
}
```

Теперь вернёмся к нашему методу `getSubItems`. Добавим в него такой код:
```java
if (tab == Tutorial.CTAB)
{
    for (AppleTypes type : AppleTypes.values())
    {
        items.add(new ItemStack(this, 1, type.ordinal()));
    }
}
```
Разберём код! Для начала начнём с проверки на вкладку креатива, если данная проверка будет отсутствовать, ваши мета-предметы будут добавлены во все вкладки, которые существуют в Minecraft. Лучше добавить проверку на свою вкладку, как сделано в данном примере. `Tutorial.CTAB` - это ранее созданная нами вкладка. Далее мы с помощью цикла проходимся по всем типам нашего предмета, затем добавляем в лист ItemStack.
- `this` - это наш предмет
- `1` - это число предметов которое содержится в стаке. Если вы хотите, чтобы один из ваших типов выдавался в количестве 5-10-15 шт., то вместо `1` укажите любое другое количество.
- `type.ordinal` - это id нашего типа. В данном случаи у нас 3 типа (ANTONOVKA, PAPIROVKA, WHITEFILLING).

Регистрация такого предмета проходит как обычно, а вот добавление иконки/модели уже через событие `ModelRegistryEvent`. Создадим метод с событием `ModelRegistryEvent` в любом удобном месте (не забудьте зарегистрировать его!). Теперь добавим такой код в данный метод:
```java
final Item APPLE = ItemsRegister.APPLE;

for (AppleTypes type : AppleTypes.values())
{
    ModelLoader.setCustomModelResourceLocation(APPLE, type.ordinal(), new ModelResourceLocation(APPLE.registryName() + "_" + type.name.toLowerCase(), "inventory"));
}
```
Возможно вы зададитесь вопросом, почему мы не использовали метод `register` из `getItemModelMesher`(ранее был использован при создании предмета). Данный способ устарел и к тому же, уже больше не работает для предметов с метадатой. Поэтому регистрация рендеров с метой нужно проводить через событие `ModelRegistryEvent`!

Мы создали переменную `APPLE` в классе `ItemsRegister` и теперь получаем наш предмет в данном методе. Через ModelLoader мы устанавливаем путь до модели предмета. Через `type.name.toLowerCase()` мы получаем имя нашего типа и преобразовываем его в нижней регистр, вы можете этого не делать, если вы пишите перечисляемые типы не в верхнем регистре. Так же видно, что мы поставили нижнее подчёркивание между зарегистрированным именем предмета и именем типа, это нужно чтобы мы могли понимать, что данный тип принадлежит к конкретному предмету, и чтобы не создавать путаницы. Вид моделей нашего предмета должен быть таким: `apple_antonovka.json`. (на каждую модель, свой тип!)

## Контейнер

TODO
